# 开发环境搭建

## 一、项目简介

本项目地址 :  https://github.com/Mikaelemmmm/go-zero-looklook

整个项目使用了 go-zero 开发的微服务，基本包含了 go-zero 以及相关 go-zero 作者开发的一些中间件，所用到的技术栈基本是 go-zero 项目组的自研组件，基本是 go-zero 全家桶了

本项目开发环境推荐 docker-compose，使用直链方式，放弃服务注册发现中间件（etcd、nacos、consul等）带来的麻烦

测试、线上部署使用 K8S（也不需要 etcd、nacos、consul 等）有详细教程（搭建+部署），可以进 go-zero 社区群沟通，非常easy

项目目录结构如下：

- admin：后台代码（整合了 gin-vue-admin，充当一个后台大网关），使用 grpc 与 app 下的 rpc 业务交互，后台 gin-vue-admin 与 go-zero 的代码交互在 banner 功能上有个例子可以查看，如果不想要后台，直接删除 admin 整个文件夹，在执行一次 go mod tidy 即可
- admin/web : 后台 web 端代码，gin-vue-admin的
- app：所有业务代码包含 api、rpc 以及 mq（消息队列、延迟队列、定时任务）
- common：通用组件 error、middleware、interceptor、tool、ctxdata 等
- data：该项目包含该目录依赖所有中间件 (mysql、es、redis、grafana 等) 产生的数据，此目录下的所有内容应该在 gitignore 文件中，不需要提交。
- deploy：
  - filebeat: docker 部署 filebeat 配置
  - go-stash：go-stash 配置
  - nginx: nginx 网关配置
  - prometheus ： prometheus 配置
  - script：
    - gencode：生成 api、rpc，以及创建 kafka 语句，复制粘贴使用
    - mysql：生成 model 的 sh 工具
  - goctl: 该项目 goctl 的 template，goctl 生成自定义代码模版，tempalte 用法可参考 go-zero 文档，复制到家目录下 .goctl 即可
- doc : 该项目系列文档
- modd.conf :  modd 热加载配置文件，不要怕～它用起来很简单，关于 modd 更多用法可以去这里了解: [https://github.com/cortesi/modd](https://github.com/cortesi/modd) ， 本项目镜像只是将 golang-1.17.7-alpine 作为基础镜像安装了 modd 在内部，如果你想把 goctl、protoc、golint 等加进去，不用我的镜像直接制作一个镜像也一样的哈

## 二、用到技术栈

- k8s

- go-zero

- nginx网关

- filebeat

- kafka

- go-stash

- elasticsearch

- kibana

- prometheus

- grafana

- jaeger

- go-queue

- asynq

- asynqmon

- dtm

- docker

- docker-compose

- mysql

- redis

- gin-vue-admin

- air

- modd

- jenkins

- gitlab

- harbor

## 三、项目架构图

![gozerolooklook](./images/1/gozerolooklook.png)

## 四、业务架构图

![gozerolooklook](./images/1/go-zero-looklook-service.png)

## 五、项目环境搭建

### ⚠️搭建过程中如果遇到问题，可以看 "九、常见错误"

本项目采用modd热加载功即时修改代码及时生效，并且不需要每次都要重启，改了代码自动就在容器中重新加载了，本地不需要启动服务，本地安装的sdk就是写代码自动提示使用的，实际运行是以来容器中 lyumikael/go-modd-env:v1.0.0的golang环境。所以使用goland、vscode都一样

【注意】由于本项目本来中间件比较多，在非linux上启动docker可能会消耗内存较多，建议将物理机分配给docker的内存调到8G

### 1、clone 代码&更新依赖

```shell
$ git clone https://github.com/Mikaelemmmm/go-zero-looklook
$
$ go mod tidy
```

#### 2、启动项目所依赖的环境

```shell
$ docker-compose -f docker-compose-env.yml up -d
```

### 3、导入数据

#### 3.1 创建 kafka topic

系统内使用了 3 个 topic，默认是不允许程序自动创建 topic 的，进入 kafka 的容器创建 3 个 topic

进入容器

```shell
$ docker exec -it kafka /bin/sh
$
$ cd /opt/kafka/bin/
```

创建3个topic

```shell
$ ./kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 -partitions 1 --topic looklook-log
$
$ ./kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 -partitions 1 --topic payment-update-paystatus-topic
$
$ ./kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 -partitions 1 --topic send-wx-mini-tpl-message
$
```

looklook-log ： 日志收集使用的

payment-update-paystatus-topic ： 支付成功通知

send-wx-mini-tpl-message：发送微信小程序通知

#### 3.2导入mysql数据

本地工具连接 mysql 的话要先进入容器，给 root 设置下远程连接权限，设置远程连接权限后，一定要先创建数据库

【注意】⚠️：
**数据库一定要先创建！！！，否则之后会报错！**
**数据库一定要先创建！！！，否则之后会报错！**
**数据库一定要先创建！！！，否则之后会报错！**

主要是四个数据库：looklook_order、looklook_payment、looklook_travel、looklook_usercenter，再分别导入相应的 SQL 执行脚本。

先在项目文件夹根目录的 deploy 下执行以下 shell 指令，

```shell
$ docker cp sql/ mysql:/tmp/
$ docker exec -it mysql mysql -uroot -p
## 输入密码：PXDN93VRKUm8TeE7
$ use mysql;
$ update user set host='%' where user='root';
$ FLUSH PRIVILEGES;
## 以下为创建数据库并导入数据库 SQL 文件
$ create database looklook_order;
$ create database looklook_payment;
$ create database looklook_travel;
$ create database looklook_usercenter;
## 以下为导入数据
$ use looklook_order;
$ source /tmp/sql/looklook_order.sql;
$
$ use looklook_payment;
$ source /tmp/sql/looklook_payment.sql;
$
$ use looklook_travel;
$ source /tmp/sql/looklook_travel.sql;
$
$ use looklook_usercenter;
$ source /tmp/sql/looklook_usercenter.sql;
```

### 4、查看服务环境

Elastic search: [http://127.0.0.1:9200/](http://127.0.0.1:9200/) （⚠️：这个启动时间有点长）

jaeger: [http://127.0.0.1:16686/search](http://127.0.0.1:16686/search)  (⚠️：如果失败了，依赖 es，因为 es 启动时间长这个有可能超时，等 es 启动玩 restart 一下)

go-stash :  看 log  (⚠️：如果你是 Mac/m1 或者 Linux/arm，请更改一下docker-compose-env.yml中 go-stash 镜像 kevinwan/go-stash:1.0-arm64 ，默认是 Linux/amd 的)

asynq （延时、定时消息队列）: [http://127.0.0.1:8980/](http://127.0.0.1:8980/)

kibana  : [http://127.0.0.1:5601/](http://127.0.0.1:5601/)

Prometheus: [http://127.0.0.1:9090/](http://127.0.0.1:9090/)

Grafana: [http://127.0.0.1:3001/](http://127.0.0.1:3001/)  ， 默认账号、密码都是 admin

Mysql :  自行客户端工具(Navicat、Sequel Pro)查看

- host : 127.0.0.1

- port : 33069  

- username : root

- pwd : PXDN93VRKUm8TeE7

Redis :  自行工具（redisManager）查看

- host : 127.0.0.1

- port : 36379

- pwd : G62m50oigInC30sf

Kafka:  自行客户端工具查看

- host : 127.0.0.1

- port : 9092

### 5、启动服务

#### 5.1 拉取运行环境镜像

因为本项目是用 docker + 热加载，即改即生效 

前台app下所有 api + rpc 服务统一使用 modd + golang

后台 admin-api 使用的 cosmtrek/air:v1.28.0

直接 docker-compose 去启动可以，但是考虑依赖可能会比较大，会影响启动项目，所以最好先把这个镜像拉取下来再去启动项目

```shell
#这个是app下所有的api+rpc启动服务使用的，如果你是 "Mac/m1" : lyumikael/go-modd-env:v1.0.0
$ docker pull lyumikael/gomodd:v1.0.0 

#这个是后台admin-api使用的 , 如果不需要后台（注意docker-compose.yaml中admin-api注释了）这个可以不用
$ docker pull cosmtrek/air:v1.28.0 
```

【注】后续如果app下新增业务，要记得在项目根目录下的modd.conf复制添加一份就可以了

​关于modd更多用法可以去这里了解 ： [https://github.com/cortesi/modd](https://github.com/cortesi/modd) ， 本项目镜像只是将 golang-1.17.7-alpine 作为基础镜像安装了modd在内部，

如果你想把 goctl、protoc、golint 等加进去，不用我的镜像直接制作一个镜像也一样的哈

#### 5.2 启动项目

```shell
$ docker-compose up -d 
```

【注】依赖的是项目根目录下的docker-compose.yml配置

### 6、查看项目运行情况

访问 [http://127.0.0.1:9090/](http://127.0.0.1:9090/) ， 点击上面菜单“Status”，在点击Targets ,蓝色的就是启动成了，红色就是没启动成功

![image-20220120103641110](./images/1/image-20220120103641110.png)

【注】如果是第一次拉取项目，每个项目容器第一次构建拉取依赖，这个看网络情况，可能会稍微比较慢有的服务，这个很正常，如果碰到项目启动不起来的情况，比如order-api ，手动在order-api代码中随便写点啥保存一下触发重新编译看看日志就可以了

```shell
$ docker-compose logs -f 
```

可以看到prometheus也显示成功了，同理把其他的也排查一次，启动成功就可以了

<img src="./images/1/image-20220120105313819.png" alt="image-20220120105313819" style="zoom:33%;" />

### 7、访问项目

由于我们使用nginx做的网关，nginx网关配置在docker-compose中，也是配置在docker-compose中，nignx对外暴露端口是8888，所以我们通过8888端口访问

```shell
$ curl  -X POST "http://127.0.0.1:8888/usercenter/v1/user/register" -H "Content-Type: application/json" -d "{\"mobile\":\"18888888888\",\"password\":\"123456\"}" 

返回:
{"code":200,"msg":"OK","data":{"accessToken":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NzM5NjY0MjUsImlhdCI6MTY0MjQzMDQyNSwiand0VXNlcklkIjo1fQ.E5-yMF0OvNpBcfr0WyDxuTq1SRWGC3yZb9_Xpxtzlyw","accessExpire":1673966425,"refreshAfter":1658198425}}
```

【注】 如果是访问nginx失败，访问成功可以忽略，可能是nginx依赖后端服务，之前因为后端服务没启动起来，nginx这里没启动起来，重启一次nginx即可,项目根目录下重启

```shell
$ docker-compose restart nginx
```

## 六、日志收集

将项目日志收集到es（filebeat收集日志->kafka -> go-stash消费kafka日志->输出到es中,kibana查看es数据）

访问kibana http://127.0.0.1:5601/ ， 创建日志索引

点击左上角菜单(三个横线那个东东)，找到Analytics - > 点击discover 

<img src="./images/1/image-20220120105829870.png" alt="image-20220120105829870" style="zoom:33%;" />

然后在当前页面，Create index pattern-> 输入 ```looklook-*``` (最好手打一遍，复制粘贴可能无法进行下一步)  -> Next Step -> 选择@timestamp -> Create index pattern

然后点击左上角菜单，找到 Analytics -> 点击discover，日志都显示了 （如果不显示，就去排查 filebeat、go-stash，使用 docker logs -f filebeat 查看）

![image-20220120105947733](./images/1/image-20220120105947733.png)

⚠️常见收集失败原因

- go-stash镜像使用错了

  看看go-stash的log ，如果出现core dumped ， 就说明镜像使用错了。

  解答:

  如果你是 Mac/m1 或者 Linux/arm，请更改一下 docker-compose-env.yml 中go-stash 镜像 kevinwan/go-stash:1.0-arm64 ，默认是 Linux/amd 的

- docker版本问题

  解答:

  这个我没有实际遇到，但是有同学使用docker版本是1.13遇到了，filebeat配置文件中配置收集 docker 的路径低版本 docker 可能位置不一样导致收集不到docker内部日志。最好升级一下 docker

  在 docker 18.03.1 以上目前都没问题，17没有实际测试， 我这边用的 docker版本是 Version: 20.10.8

- 内部kafka问题

  解答:

  1）docker logs 按照顺序检查 kafka、filbeat、go-stash、es 的容器日志，确认服务都没问题

  2）先 docker logs -f filebeat 查看 filebeat 是否正确连接到了 kafka

  3）进入 kafka 容器内，执行消费kafka-log消息，看看是否filebeat的消息已经发送到了kafka

  ```shell
  $ docker exec -it kafka /bin/sh
  $
  $ cd /opt/kafka/bin
  $
  $ ./kafka-console-consumer.sh --bootstrap-server kafka:9092 --topic looklook-log 
  $
  ```
  【注】如果能消费到消息，说明filebeat与kafka没问题，就去排查go-stash、es

    如果不能消费

    1）就应该是filebeat与kafka之间连接的问题，要去看下kafka的配置信息Listen是否修改了

    2）在kafka容器内部命令行使用consumer.sh消费looklook-log，另外一个终端命令行用producer.sh给looklook-log发送消息，如果consumer收不到，说明kafka出问题了，docker logs -f kafka看看什么问题
	
## 七、本项目镜像介绍

所有服务启动成功，应该是如下这些，自行对比

![image-20220117221816047](./images/1/image-20220117221816047.png)

- nginx : 网关 （nginx -> api -> rpc）
- cosmtrek/air : 我们业务代码开发依赖的环境镜像，之所以用这个是因为air热加载，写代码实时编译太方便了，这个镜像是 air + golang ，实际上我们启我们自己的业务服务后，我们的业务服务是运行在此镜像中的
- wurstmeister/kafka ： 业务使用的 kafka
- wurstmeister/zookeeper ： kafka 依赖的 zookeeper
- redis：业务使用的 redis
- mysql: 业务使用的数据库
- prom/prometheus：监控业务
- grafana/grafana ：prometheus 的 ui 很难看，用来显示 prometheus 收集来的数据
- elastic/filebeat ： 收集日志到 kafka
- go-stash : 消费 kafka 中日志，脱敏、过滤然后输出到 es
- docker.elastic.co/elasticsearch/elasticsearch ： 存储收集的日志
- docker.elastic.co/kibana/kibana ： 显示 elasticsearch
- jaegertracing/jaeger-query 、jaegertracing/jaeger-collector、jaegertracing/jaeger-agent：链路追踪
- go-stash : filebeat 收集日志到 kafka 后，go-stash 去消费 kafka 进行数据脱敏、过滤日志中内容，最后输出到 es 中

## 八、项目开发建议

- app下放所有业务服务代码

- common放所有服务的公共基础库

- data项目依赖中间件产生的数据，实际开发中应该在git中忽略此目录以及此目录下产生的数据

- 生成api、rpc代码：

一般我们在生成 api，rpc 代码时候手动去敲 goctl 的命令比较长，也记不住，所以我们直接去 deploy/script/gencode/gen.sh 中复制代码即可。比如我在usercenter 服务中新增加了一个业务，修改密码，写完 api 文件之后，进入到usercenter/cmd/api/desc 目录下，直接复制 deploy/script/gencode/gen.sh 中的生成 api 命令运行即可

```shell
$ goctl api go -api *.api -dir ../  -style=goZero
```

生成 rpc 也一样，在写完 proto 文件后，直接粘复制 deploy/script/gencode/gen.sh 中的生成rpc命令运行即可

goctl >= 1.3 进入"服务/cmd/rpc/pb"目录下，执行下面命令

```shell
$ goctl rpc protoc *.proto --go_out=../ --go-grpc_out=../  --zrpc_out=../
$ sed -i "" 's/,omitempty//g' *.pb.go
```

goctl < 1.3 进入"服务/cmd"目录下，执行下面命令

```shell
$  goctl rpc proto -src rpc/pb/*.proto -dir ./rpc -style=goZero
$  sed -i "" 's/,omitempty//g'  ./rpc/pb/*.pb.go
```

【注】建议在生成 rpc 文件时候，在多执行一次下面那个命令，把 protobuf 生成的 omitempty 给删除掉，不然字段为 nil 就不返回了

- 生成 kafka 代码：

  因为本项目使用了 go-queue 的 kq 做消息队列，kq 又依赖的 kafka，实际就是使用了 kafka 做消息队列，但是 kq 默认是需要我们提前把 topic 建好的，不许默认自动生成，所以命令也准备好了，直接复制 deploy/script/gencode/gen.sh 中的创建 kafka 的 topic 代码即可

  ```shell
   kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 -partitions 1 --topic {topic}
  ```

- 生成model代码，直接运行 deploy/script/mysql/genModel.sh  参数

- api 项目中的 .api 文件我们做了拆分，统一放到每个 api 的 desc 文件夹下，因为如果所有内容都写在 api 中可能不便于查看，所以做了拆分，把所有方法写到一个 api 中，其他的实体以及 req、rep 统一放到一个文件夹单独定义比较清晰

- 生成 model、错误处理时候使用了 template 重新定义，该项目用到的自定义的 goctl 的模版在项目 deploy/goctl 下

## 九、搭建环境常见错误

1、创建阶段，起 docker-compose-env.yml 容器
Grafana 报错:

```You may have issues with file permissions, more information here: http://docs.grafana.org/installation/docker/#migrate-to-v51-or-later```

```mkdir: can't create directory '/var/lib/grafana/plugins': Permission denied```

因权限问题导致，可在 docker-compose-env.yml 中 grafana 部分加入 user: root

2、filebeat 容器启动报错

```Exiting: error loading config file: config file ("filebeat.yml") must be owned by the user identifier (uid=0) or root```

因文件所有者不同导致（我在普通用户下 clone 的项目），filebeat 的配置文件所有者必须为 root，需修改 sudo chown root deploy/filebeat/conf/filebeat.yml

3、elasticsearch 容器启动报错

```ElasticsearchException[failed to bind service]; nested: AccessDeniedException[/usr/share/elasticsearch/data/nodes];```

```Likely root cause: java.nio.file.AccessDeniedException: /usr/share/elasticsearch/data/nodes```

报错原因 es 没有权限操作挂载目录，无法绑定节点，解决方法，修改权限 sudo chmod 777 data/elasticsearch/data （不知道es是哪个用户启动的，所以硬改了777）

4、jaeger 依赖于 elasticsearch，且没有失败自动重启

## 十、后台启动

考虑到在开发中如果自己重新写一个后台要做 rbac 等还是比较麻烦的，直接把 gin-vue-admin 低代码平台整合进来直接用就可以了，但是架构上面是要考虑下，

我们把整个后台 gin-vue-admin 的 api 接口充当一整个大网关使用即可，这里面不写任何跟业务相关操作，所有业务都要通过 grpc 去跟 app 下业务的 rpc 要数据，前台根据业务拆分了不同 api，后台只需要一个大的 api 就可以了。

问：为什么不是把后台单独抽离出去单独做一个系统？

答：因为在项目中我们使用了db层缓存，将缓存key统一定义在model中，如果独立一个系统这个缓存key我们又要单独copy一份过去，这期间可能会出现遗漏等问题	，所以直接使用grpc去调用就可以了。


### 1、启动项目

进入 MySQL 下创建数据库 looklook_admin 并导入 deploy/sql/looklook_admin.sql 数据

```shell
$ docker-compose -f docker-compose-admin.yml up -d
$
$ docker exec -it mysql mysql -uroot -p
##输入密码：PXDN93VRKUm8TeE7
$ create database looklook_admin;
$ use database looklook_admin;
$ source /tmp/sql/looklook_admin.sql

```



可以查看日志

```sh
$ docker logs -f admin-api
```

如果查看后台日志出现如下问题：

```2022/03/10 17:20:46 rpc dial: direct:///looklook:8008, error: context deadline exceeded, make sure rpc service "looklook:8008" is already started```

这是因为 admin-api 先启动了，它依赖后端的 banner 由于下载以来慢一点没启动起来，这时候等looklook中的banner启动起来之后，重启一下 admin-api 就好了

```sh
$ docker-compose restart admin-api
```

现在我们只需要启动后台前端 web 即可，进入 admin/web 下，执行如下命令

```shell
$ npm install 
$
$ npm run serve
```

默认会打开 [http://localhost:7082/#/init](http://localhost:7082/#/init)

【注】不要点击“前往初始化”，否则配置文件就会被覆盖了

账号：admin

密码：123456

整个项目就是 gin-vue-admin ，如果有不懂的直接去看 gin-vue-admin 官方即可，他们还有视频教程

只是在 gin-vue-admin 上加了一个如何跟 go-zero 交互调用，登陆进入后台，点击菜单最下方广告管理，这个功能可以看 admin-api 中调用 app/banner-rpc 例子，就不再详细说明了

## 十一、后续

由于项目中由于涉及到的技术栈稍微有点多，将逐步分章节一点点添加
